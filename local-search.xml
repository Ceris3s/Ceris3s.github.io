<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>clusterfuzz踩坑实录</title>
    <link href="/2022/02/26/clusterfuzz%E8%B8%A9%E5%9D%91%E5%AE%9E%E5%BD%95/"/>
    <url>/2022/02/26/clusterfuzz%E8%B8%A9%E5%9D%91%E5%AE%9E%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Getting-started"><a href="#Getting-started" class="headerlink" title="Getting started"></a>Getting started</h1><p>设置环境可参考<a href="https://google.github.io/clusterfuzz/getting-started/prerequisites/">https://google.github.io/clusterfuzz/getting-started/prerequisites/</a></p><p>我用的ClusterFuzz 版本位v2.5.6</p><h2 id="Running-a-local-server"><a href="#Running-a-local-server" class="headerlink" title="Running a local server"></a>Running a local server</h2><p>You can start a local server by running the following command:</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vim"># If you run the server <span class="hljs-keyword">for</span> the <span class="hljs-keyword">first</span> time <span class="hljs-built_in">or</span> want <span class="hljs-keyword">to</span> reset <span class="hljs-keyword">all</span> data.<br><span class="hljs-keyword">python</span> butler.<span class="hljs-keyword">py</span> run_server --bootstrap<br><br># In <span class="hljs-keyword">all</span> the other cases, <span class="hljs-keyword">do</span> not use <span class="hljs-string">&quot;--bootstrap&quot;</span> flag.<br><span class="hljs-keyword">python</span> butler.<span class="hljs-keyword">py</span> run_server<br></code></pre></td></tr></table></figure><p>错误：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs gradle">|   <span class="hljs-keyword">File</span> <span class="hljs-string">&quot;/home/fuzzer/clusterfuzz/src/appengine/main.py&quot;</span>, line <span class="hljs-number">42</span>, in &lt;module&gt;<br>|     <span class="hljs-keyword">import</span> server<br>|   <span class="hljs-keyword">File</span> <span class="hljs-string">&quot;/home/fuzzer/clusterfuzz/src/appengine/server.py&quot;</span>, line <span class="hljs-number">16</span>, in &lt;module&gt;<br>|     <span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask<br>|   <span class="hljs-keyword">File</span> <span class="hljs-string">&quot;/home/fuzzer/clusterfuzz/src/appengine/third_party/flask/__init__.py&quot;</span>, line <span class="hljs-number">14</span>, in &lt;module&gt;<br>|     <span class="hljs-keyword">from</span> jinja2 <span class="hljs-keyword">import</span> escape<br>|   <span class="hljs-keyword">File</span> <span class="hljs-string">&quot;/home/fuzzer/clusterfuzz/src/appengine/third_party/jinja2/__init__.py&quot;</span>, line <span class="hljs-number">12</span>, in &lt;module&gt;<br>|     <span class="hljs-keyword">from</span> .environment <span class="hljs-keyword">import</span> Environment<br>|   <span class="hljs-keyword">File</span> <span class="hljs-string">&quot;/home/fuzzer/clusterfuzz/src/appengine/third_party/jinja2/environment.py&quot;</span>, line <span class="hljs-number">25</span>, in &lt;module&gt;<br>|     <span class="hljs-keyword">from</span> .defaults <span class="hljs-keyword">import</span> BLOCK_END_STRING<br>|   <span class="hljs-keyword">File</span> <span class="hljs-string">&quot;/home/fuzzer/clusterfuzz/src/appengine/third_party/jinja2/defaults.py&quot;</span>, line <span class="hljs-number">3</span>, in &lt;module&gt;<br>|     <span class="hljs-keyword">from</span> .filters <span class="hljs-keyword">import</span> FILTERS as DEFAULT_FILTERS  # noqa: F401<br>|   <span class="hljs-keyword">File</span> <span class="hljs-string">&quot;/home/fuzzer/clusterfuzz/src/appengine/third_party/jinja2/filters.py&quot;</span>, line <span class="hljs-number">13</span>, in &lt;module&gt;<br>|     <span class="hljs-keyword">from</span> markupsafe <span class="hljs-keyword">import</span> soft_unicode<br>| ImportError: cannot <span class="hljs-keyword">import</span> name <span class="hljs-string">&#x27;soft_unicode&#x27;</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;markupsafe&#x27;</span> (<span class="hljs-regexp">/home/</span>fuzzer<span class="hljs-regexp">/clusterfuzz/</span>src<span class="hljs-regexp">/appengine/</span>third_party<span class="hljs-regexp">/markupsafe/</span>__init__.py)<br><br></code></pre></td></tr></table></figure><p>到出错模块的目录看了下markupsafe的版本__version__ = “2.1.0”，再看其官网的公告<a href="https://markupsafe.palletsprojects.com/en/2.1.x/changes/#version-2-1-0%EF%BC%8C%E8%A1%A8%E7%A4%BA%EF%BC%9A">https://markupsafe.palletsprojects.com/en/2.1.x/changes/#version-2-1-0，表示：</a></p><ul><li>Remove <code>soft_unicode</code>, which was previously deprecated. Use <code>soft_str</code> instead. <a href="https://github.com/pallets/markupsafe/pull/261">#261</a></li></ul><p>那就修改一下clusterfuzz/src/appengine/third_party/jinja2/filters.py这个文件，将</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">from</span> markupsafe <span class="hljs-keyword">import</span> soft_unicode<br></code></pre></td></tr></table></figure><p>改为</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">from</span> markupsafe <span class="hljs-keyword">import</span> soft_str<br></code></pre></td></tr></table></figure><p>发现修改还不行，一运行butler.py就会安装Jinja2==2.11.3，看了下<a href="https://github.com/pallets/jinja%EF%BC%8C%E6%9C%80%E6%96%B0%E7%89%88%E5%B7%B2%E7%BB%8F%E8%A7%A3%E5%86%B3%E4%BA%86%E8%AF%A5%E9%97%AE%E9%A2%98%E3%80%82">https://github.com/pallets/jinja，最新版已经解决了该问题。</a></p><p>那就把clusterfuzz/src/appengine/requirements.txt版本改到最新</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Jinja2</span>==<span class="hljs-number">3</span>.<span class="hljs-number">0</span>.<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>这个解决了，又有新的报错：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs gradle">   <span class="hljs-keyword">File</span> <span class="hljs-string">&quot;/home/fuzzer/clusterfuzz/src/appengine/main.py&quot;</span>, line <span class="hljs-number">42</span>, in &lt;module&gt;<br>|     <span class="hljs-keyword">import</span> server<br>|   <span class="hljs-keyword">File</span> <span class="hljs-string">&quot;/home/fuzzer/clusterfuzz/src/appengine/server.py&quot;</span>, line <span class="hljs-number">16</span>, in &lt;module&gt;<br>|     <span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask<br>|   <span class="hljs-keyword">File</span> <span class="hljs-string">&quot;/home/fuzzer/clusterfuzz/src/appengine/third_party/flask/__init__.py&quot;</span>, line <span class="hljs-number">19</span>, in &lt;module&gt;<br>|     <span class="hljs-keyword">from</span> . <span class="hljs-keyword">import</span> json<br>|   <span class="hljs-keyword">File</span> <span class="hljs-string">&quot;/home/fuzzer/clusterfuzz/src/appengine/third_party/flask/json/__init__.py&quot;</span>, line <span class="hljs-number">15</span>, in &lt;module&gt;<br>|     <span class="hljs-keyword">from</span> itsdangerous <span class="hljs-keyword">import</span> json as _json<br>| ImportError: cannot <span class="hljs-keyword">import</span> name <span class="hljs-string">&#x27;json&#x27;</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;itsdangerous&#x27;</span> (<span class="hljs-regexp">/home/</span>fuzzer<span class="hljs-regexp">/clusterfuzz/</span>src<span class="hljs-regexp">/appengine/</span>third_party<span class="hljs-regexp">/itsdangerous/</span>__init__.py)<br><br></code></pre></td></tr></table></figure><p>按照网友的描述，把flask升到新版，参考<a href="https://stackoverflow.com/questions/71189819/python-docker-importerror-cannot-import-name-json-from-itsdangerous">https://stackoverflow.com/questions/71189819/python-docker-importerror-cannot-import-name-json-from-itsdangerous</a></p><p>成功啦~</p><p><img src="2022-02-26_141509.png"></p><h2 id="Running-a-local-bot-instance"><a href="#Running-a-local-bot-instance" class="headerlink" title="Running a local bot instance"></a>Running a local bot instance</h2><p>您可以通过运行以下命令在本地实例中运行ClusterFuzz机器人:</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">python</span> butler.<span class="hljs-keyword">py</span> run_bot --name <span class="hljs-keyword">po</span>-bot `<span class="hljs-keyword">pwd</span>`/<span class="hljs-keyword">po</span>-bot<br></code></pre></td></tr></table></figure><p>执行成功后，可在前一步的管理员界面看到机器人状态。</p><p><img src="2022-02-26_155324.png"></p><h3 id="Viewing-logs"><a href="#Viewing-logs" class="headerlink" title="Viewing logs"></a>Viewing logs</h3><p>您可以通过运行以下命令查看本地实例上的日志:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">tail -f `pwd`<span class="hljs-regexp">/po-bot/</span>clusterfuzz<span class="hljs-regexp">/bot/</span>logs/bot.log<br></code></pre></td></tr></table></figure><h1 id="Setting-up-fuzzing"><a href="#Setting-up-fuzzing" class="headerlink" title="Setting up fuzzing"></a>Setting up fuzzing</h1><h2 id="libFuzzer-and-AFL"><a href="#libFuzzer-and-AFL" class="headerlink" title="libFuzzer and AFL"></a>libFuzzer and AFL</h2><h3 id="Prerequisites"><a href="#Prerequisites" class="headerlink" title="Prerequisites"></a>Prerequisites</h3><h4 id="Compiler"><a href="#Compiler" class="headerlink" title="Compiler"></a>Compiler</h4><p>LibFuzzer和AFL均需要使用Clang编译器进行代码插装. 在本文档中, 我们采用的版本为Clang <strong>6.0</strong>及更高. 但为了更好的使用ClusterFuzz, 我们建议使用Clang最新稳定版本. 要获得Clang最新稳定版本，您可以从<a href="https://llvm.org/builds/">快照页面</a>（Windows）下载它，或按照<a href="https://apt.llvm.org/">apt页</a> (Ubuntu / Debian)上的说明进行操作。 否则，您可以从<a href="http://releases.llvm.org/download.html">发布页面</a>下载Clang发行版，或使用包管理器安装一个Clang发行版。 我们将在示例中将这些编译器称为<code>$CC</code>和<code>$CXX</code>。 在环境中进行设置，以便您可以复制并粘贴示例命令：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">CC</span>=/path/to/clang<br><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">CXX</span>=/path/to/clang++<br></code></pre></td></tr></table></figure><p>比如我本地是</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">CC</span>=/usr/bin/clang<br><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">CXX</span>=/usr/bin/clang++<br></code></pre></td></tr></table></figure><h4 id="Platform"><a href="#Platform" class="headerlink" title="Platform"></a>Platform</h4><p>Linux, macOS和Windows均支持libFuzzer. 对于Windows平台, 您需要在cmd.exe中运行命令, 并且需要<strong>9.0</strong>或更高版本的Clang支持, 您可以从<a href="https://llvm.org/builds/">LLVM Snapshot Builds页面</a>下载合适的版本.</p><p>AFL则仅支持在Linux平台上运行.</p><h3 id="Builds"><a href="#Builds" class="headerlink" title="Builds"></a>Builds</h3><h4 id="libFuzzer"><a href="#libFuzzer" class="headerlink" title="libFuzzer"></a>libFuzzer</h4><p>LibFuzzer的目标十分容易进行构建. 只需要通过选项<code>-fsanitize=fuzzer</code>编译链接<a href="https://llvm.org/docs/LibFuzzer.html#id22">fuzz target</a>和例如<a href="https://clang.llvm.org/docs/AddressSanitizer.html">AddressSanitizer</a>这样的sanitizer (<code>-fsanitize=address</code>)即可.</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-variable">$CXX</span> <span class="hljs-attribute">-fsanitize</span>=address,fuzzer fuzzer.cc -o fuzzer<br><span class="hljs-comment"># 通过运行来测试构建的Fuzzer</span><br>./fuzzer <span class="hljs-attribute">-runs</span>=10<br><span class="hljs-comment"># 将Fuzzer打包上传到ClusterFuzz.</span><br>zip fuzzer-build.zip fuzzer<br></code></pre></td></tr></table></figure><p>libFuzzer构建包是包含您要Fuzz的目标及其依赖项的Zip归档文件.</p><h3 id="AFL"><a href="#AFL" class="headerlink" title="AFL"></a>AFL</h3><p>ClusterFuzz支持使用AFL ++来fuzzing libFuzzer的harness功能（<code>LLVMFuzzerTestOneInput</code>）。 AFL ++必须与<a href="https://clang.llvm.org/docs/AddressSanitizer.html">AddressSanitizer</a>一起使用。 要为AFL构建fuzz目标，请运行我们的<a href="https://vancir.github.io/clusterfuzz-document-cn/setting-up-fuzzing/build_afl.bash">script</a>，该脚本下载并构建AFL和<code>FuzzingEngine.a</code>，您可以将目标链接到该库以使其与AFL兼容。 然后使用-fsanitize-coverage = trace-pc-guard和-fsanitize = address编译并链接目标。</p><p>注意:由于将不会启用CMPLOG和COMPCOV之类的高级模糊功能，因此不会充分利用AFL ++。 因此，建议使用oss-fuzz代替创建（多个）模糊测试软件包，因为每个软件包都带有随机选项。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># Build afl-fuzz and FuzzingEngine.a 生成afl-fuzz和FuzzingEngine.a</span><br>./build_afl.bash<br><span class="hljs-comment"># Compile target using ASan, coverage instrumentation, and link against FuzzingEngine.a 使用ASan，coverage工具和针对FuzzingEngine.a的链接来编译目标</span><br><span class="hljs-variable">$CXX</span> <span class="hljs-attribute">-fsanitize</span>=address <span class="hljs-attribute">-fsanitize-coverage</span>=trace-pc-guard fuzzer.cc FuzzingEngine.a -o fuzzer<br><span class="hljs-comment"># Test out the build by fuzzing it. INPUT_CORPUS is a directory containing files. Ctrl-C when done. 通过模糊测试构建。 INPUT_CORPUS是包含文件的目录。 完成后，请按Ctrl-C。</span><br><span class="hljs-attribute">AFL_SKIP_CPUFREQ</span>=1 ./afl-fuzz -i <span class="hljs-variable">$INPUT_CORPUS</span> -o output -m none ./fuzzer<br><span class="hljs-comment"># Create a fuzzer build to upload to ClusterFuzz. 创建一个模糊器构建以上载到ClusterFuzz。</span><br>zip fuzzer-build.zip fuzzer afl-fuzz afl-showmap<br></code></pre></td></tr></table></figure><p>AFL构建是zip文件，其中包含您要fuzz的任何目标，它们的依赖关系以及AFL的依赖关系：<code>afl-fuzz</code>和<code>afl-showmap</code>（均由script构建）。</p><h1 id="Finding-Heartbleed"><a href="#Finding-Heartbleed" class="headerlink" title="Finding Heartbleed"></a>Finding Heartbleed</h1><h2 id="Prerequisites-1"><a href="#Prerequisites-1" class="headerlink" title="Prerequisites"></a>Prerequisites</h2><p>假设您现在正在使用一台Linux bot. 查阅位于libFuzzer和AFL++文档里的编译器段落, 获取以下示例的可用编译器, 并确保设置好了<code>CC</code>和<code>CXX</code>环境变量.</p><h2 id="Building-a-libFuzzer-target-for-OpenSSL"><a href="#Building-a-libFuzzer-target-for-OpenSSL" class="headerlink" title="Building a libFuzzer target for OpenSSL"></a>Building a libFuzzer target for OpenSSL</h2><p>运行以下命令构建一个用于OpenSSL的libFuzzer target.</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># 下载和解压一份受漏洞影响的OpenSSL版本代码</span><br>curl -O https:<span class="hljs-regexp">//</span>ftp.openssl.org<span class="hljs-regexp">/source/</span>old<span class="hljs-regexp">/1.0.1/</span>openssl-<span class="hljs-number">1.0</span>.<span class="hljs-number">1</span>f.tar.gz<br>tar xf openssl-<span class="hljs-number">1.0</span>.<span class="hljs-number">1</span>f.tar.gz<br><br><span class="hljs-comment"># 构建带有ASan和fuzzer插装的OpenSSL</span><br>cd openssl-<span class="hljs-number">1.0</span>.<span class="hljs-number">1</span>f/<br>./config<br><br><span class="hljs-comment"># $CC必须指向clang二进制文件, 如何设置请查看上述&quot;编译器段落&quot;链接</span><br>make CC=<span class="hljs-string">&quot;$CC -g -fsanitize=address,fuzzer-no-link&quot;</span><br>cd ..<br>mkdir fuzz<br>cd fuzz<br><span class="hljs-comment"># 下载fuzz target及其依赖的数据. </span><br>curl -O https:<span class="hljs-regexp">//</span>raw.githubusercontent.com<span class="hljs-regexp">/google/</span>clusterfuzz<span class="hljs-regexp">/master/</span>docs<span class="hljs-regexp">/setting-up-fuzzing/</span>heartbleed/handshake-fuzzer.cc<br>curl -O https:<span class="hljs-regexp">//</span>raw.githubusercontent.com<span class="hljs-regexp">/google/</span>clusterfuzz<span class="hljs-regexp">/master/</span>docs<span class="hljs-regexp">/setting-up-fuzzing/</span>heartbleed/server.key<br>curl -O https:<span class="hljs-regexp">//</span>raw.githubusercontent.com<span class="hljs-regexp">/google/</span>clusterfuzz<span class="hljs-regexp">/master/</span>docs<span class="hljs-regexp">/setting-up-fuzzing/</span>heartbleed/server.pem<br><br><span class="hljs-comment"># 构建用于ClusterFuzz的OpenSSL fuzz target ($CXX需要指向clang++二进制文件):</span><br><span class="hljs-variable">$CXX</span> -g handshake-fuzzer.cc -fsanitize=address,fuzzer ..<span class="hljs-regexp">/openssl-1.0.1f/</span>libssl.a \<br>  ..<span class="hljs-regexp">/openssl-1.0.1f/</span>libcrypto.a -std=c++<span class="hljs-number">17</span> -I..<span class="hljs-regexp">/openssl-1.0.1f/i</span>nclude/ -lstdc++fs   \<br>  -ldl -lstdc++ -o handshake-fuzzer<br><br>zip openssl-fuzzer-build.zip handshake-fuzzer server.key server.pem<br></code></pre></td></tr></table></figure><h2 id="Uploading-the-fuzzer-to-ClusterFuzz"><a href="#Uploading-the-fuzzer-to-ClusterFuzz" class="headerlink" title="Uploading the fuzzer to ClusterFuzz"></a>Uploading the fuzzer to ClusterFuzz</h2><p>首先我们需要创建一个任务:</p><ul><li>导航至<em>Jobs</em>页面.</li><li>来到”ADD NEW JOB”表单处.</li><li>依照以下内容填充任务信息:<ul><li>填写<strong>“libfuzzer_asan_linux_openssl”</strong> 至 “Name”.</li><li>填写<strong>“LINUX”</strong> 至 “Platform”.</li><li>填写<strong>“libFuzzer”</strong> 至 “Select/modify fuzzers”.</li><li>填写<strong>“libfuzzer”</strong> 和 <strong>“engine_asan”</strong> 至 “Templates”.</li><li>填写<code>CORPUS_PRUNE = True</code> 至 “Environment String”.</li></ul></li><li>选择 openssl-fuzzer-build.zip并上传为”Custom Build”.</li><li>使用”ADD”按钮将该Job添加至ClusterFuzz.</li></ul><h2 id="Fuzzing-and-seeing-results"><a href="#Fuzzing-and-seeing-results" class="headerlink" title="Fuzzing and seeing results"></a>Fuzzing and seeing results</h2><p>如果您遵照local ClusterFuzz教程配置好了本地的server和bot实例, 并且同时也没有其他任何fuzzing任务正在运行, 那么您接下来应该就能在bot logs处看到<code>fuzz libFuzzer libfuzzer_asan_linux_openssl</code>的字样. 这代表着ClusterFuzz正在对您构建的代码进行模糊测试. </p><p><img src="2022-02-26_175048.png"></p><p>不久后您就能在日志里看到崩溃栈信息以及字符串<code>AddressSanitizer: heap-buffer-overflow</code>.</p><p><img src="2022-02-26_175426.png"></p><p>如果您遵照的是教程production instance of ClusterFuzz, 那么您可以在<em>Bots</em>页面看到<code>fuzz libFuzzer libfuzzer_asan_linux_openssl</code>字样. 具体花费的时间取决于您可能承担的其他工作负荷.</p><p>随后, 您可以转到ClusterFuzz首页(或者<em>Testcases</em>页面), 您将会看到一个标题名为<strong>“Heap-buffer-overflow READ{*}”</strong>的测试用例. 这就是由ClusterFuzz发现的心脏滴血漏洞.</p><p><img src="2022-02-26_180006.png"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://google.github.io/clusterfuzz/">https://google.github.io/clusterfuzz/</a></p><p><a href="https://myfzy.top/2020/05/15/clusterfuzz%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8D%97/">https://myfzy.top/2020/05/15/clusterfuzz%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8D%97/</a></p><p><a href="https://vancir.github.io/clusterfuzz-document-cn/">https://vancir.github.io/clusterfuzz-document-cn/</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu issues</title>
    <link href="/2022/02/22/ubuntu_issues/"/>
    <url>/2022/02/22/ubuntu_issues/</url>
    
    <content type="html"><![CDATA[<h2 id="network"><a href="#network" class="headerlink" title="network"></a>network</h2><p>restart your network regardless network management configuration settings:</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">sudo netplan <span class="hljs-built_in">apply</span><br></code></pre></td></tr></table></figure><h5 id="Network-restart-for-networkd-managed-systems"><a href="#Network-restart-for-networkd-managed-systems" class="headerlink" title="Network restart for networkd managed systems"></a>Network restart for networkd managed systems</h5><p>The following commands will restart network interface enp0s3</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">$ sudo<span class="hljs-built_in"> ip </span>link <span class="hljs-builtin-name">set</span> enp0s3 down<br>$ sudo<span class="hljs-built_in"> ip </span>link <span class="hljs-builtin-name">set</span> enp0s3 up<br></code></pre></td></tr></table></figure><h5 id="Network-restart-for-NetworkManager-managed-systems"><a href="#Network-restart-for-NetworkManager-managed-systems" class="headerlink" title="Network restart for NetworkManager managed systems"></a>Network restart for NetworkManager managed systems</h5><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake">$ sudo nmcli networking <span class="hljs-keyword">off</span><br>$ sudo nmcli networking <span class="hljs-keyword">on</span><br></code></pre></td></tr></table></figure><p>this works for me, the network works again.</p><p>Alternatively you can try to restart your network with System V init script:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ sudo <span class="hljs-regexp">/etc/i</span>nit.d/network-manager restart<br></code></pre></td></tr></table></figure><p>Ref：<a href="https://linuxconfig.org/how-to-restart-network-on-ubuntu-20-04-lts-focal-fossa">https://linuxconfig.org/how-to-restart-network-on-ubuntu-20-04-lts-focal-fossa</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Fuzzing linux kernel with syzkaller</title>
    <link href="/2022/02/20/syzkaller-fuzzing/"/>
    <url>/2022/02/20/syzkaller-fuzzing/</url>
    
    <content type="html"><![CDATA[<h2 id="安装基本软件"><a href="#安装基本软件" class="headerlink" title="安装基本软件"></a>安装基本软件</h2><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs q"><br>sudo apt-<span class="hljs-built_in">get</span> install debootstrap<br>sudo apt install qemu-kvm<br>sudo apt-<span class="hljs-built_in">get</span> install subversion<br>sudo apt-<span class="hljs-built_in">get</span> install git<br>sudo apt-<span class="hljs-built_in">get</span> install make<br>sudo apt-<span class="hljs-built_in">get</span> install qemu<br>sudo apt install libssl-<span class="hljs-built_in">dev</span> libelf-<span class="hljs-built_in">dev</span><br>sudo apt-<span class="hljs-built_in">get</span> install flex bison libc6-<span class="hljs-built_in">dev</span> libc6-<span class="hljs-built_in">dev</span>-i386 linux-libc-<span class="hljs-built_in">dev</span> linux-libc-<span class="hljs-built_in">dev</span>:i386 libgmp3-<span class="hljs-built_in">dev</span> libmpfr-<span class="hljs-built_in">dev</span> libmpc-<span class="hljs-built_in">dev</span><br>sudo apt-<span class="hljs-built_in">get</span> install g++<br>sudo apt-<span class="hljs-built_in">get</span> install build-essential<br>sudo apt install gcc<br>sudo apt install openssh-server<br></code></pre></td></tr></table></figure><p>安装go编程语言并没有使用apt install golang-go，使用apt安装的go编程语言版本为1.10，使用这个版本的go会在编译syzkaller时报错，所以在这选择下载安装1.17版本的go</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://dl.google.com/go/go1.17.6.linux-amd64.tar.gz<br>tar -zxvf go1.17.6.linux-amd64.tar.gz <br><span class="hljs-built_in">export</span> GOPATH=/home/<span class="hljs-built_in">test</span>/git/go/go //路径替换为自己虚拟机中的路径<br><span class="hljs-built_in">export</span> GOROOT=/home/<span class="hljs-built_in">test</span>/git/go/go<br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$GOPATH</span>/bin:<span class="hljs-variable">$PATH</span><br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$GOROOT</span>/bin:<span class="hljs-variable">$PATH</span><br></code></pre></td></tr></table></figure><p>运行go命令可以执行，即为安装成功。</p><h2 id="编译syzkaller"><a href="#编译syzkaller" class="headerlink" title="编译syzkaller"></a>编译syzkaller</h2><p>使用下面的命令拉取编译syzkaller代码。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/google/</span>syzkaller.git<br>cd syzkaller<br>make <br></code></pre></td></tr></table></figure><p>报错</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs elixir">cerises<span class="hljs-variable">@ubuntu</span><span class="hljs-symbol">:~/Desktop/syzkaller</span><span class="hljs-variable">$ </span>make<br><br><br><span class="hljs-symbol">go:</span> cloud.google.com/go<span class="hljs-variable">@v0</span>.<span class="hljs-number">81.0</span>: Get <span class="hljs-symbol">https:</span>/<span class="hljs-regexp">/proxy.golang.org/cloud</span>.google.com/go/<span class="hljs-variable">@v</span>/<span class="hljs-symbol">v0.81.0.mod:</span> dial tcp <span class="hljs-number">172.217</span>.<span class="hljs-number">163.49</span><span class="hljs-symbol">:</span><span class="hljs-number">443</span>: i/o timeout<br><span class="hljs-symbol">Makefile:</span><span class="hljs-number">39</span>: *** syz-make failed.  Stop.<br></code></pre></td></tr></table></figure><p>把 Go 模块代理更换成Goproxy.cn 就解决了</p><p><strong>用法</strong></p><p><strong>Go 1.13 及以上（推荐）</strong></p><p>打开你的终端并执行</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vim">$ <span class="hljs-keyword">go</span> env -<span class="hljs-keyword">w</span> GO111MODULE=<span class="hljs-keyword">on</span><br>$ <span class="hljs-keyword">go</span> env -<span class="hljs-keyword">w</span> GOPROXY=http<span class="hljs-variable">s:</span>//goproxy.<span class="hljs-keyword">cn</span>,direct<br></code></pre></td></tr></table></figure><p>完成。</p><p><strong>macOS 或 Linux</strong></p><p>打开你的终端并执行</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">$ <span class="hljs-builtin-name">export</span> <span class="hljs-attribute">GO111MODULE</span>=on<br>$ <span class="hljs-builtin-name">export</span> <span class="hljs-attribute">GOPROXY</span>=https://goproxy.cn<br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;export GO111MODULE=on&quot;</span> &gt;&gt; ~/.profile</span><br><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;export GOPROXY=https://goproxy.cn&quot;</span> &gt;&gt; ~/.profile</span><br><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">source</span> ~/.profile</span><br></code></pre></td></tr></table></figure><p>完成。</p><p>参考<a href="https://github.com/goproxy/goproxy.cn/blob/master/README.zh-CN.md">https://github.com/goproxy/goproxy.cn/blob/master/README.zh-CN.md</a></p><h2 id="编译Linux内核"><a href="#编译Linux内核" class="headerlink" title="编译Linux内核"></a>编译Linux内核</h2><p>git拉取linux代码：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">git clone https:<span class="hljs-regexp">//mi</span>rrors.tuna.tsinghua.edu.cn<span class="hljs-regexp">/git/</span>linux.git<br>cd linux<br></code></pre></td></tr></table></figure><p>进入linux目录后使用如下命令进行配置：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-built_in">make</span> CC=<span class="hljs-string">&quot;/usr/bin/gcc&quot;</span> defconfig<br><span class="hljs-built_in">make</span> CC=<span class="hljs-string">&quot;/usr/bin/gcc&quot;</span> kvm_guest.config  <br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Coverage collection.</span><br>CONFIG_KCOV=y<br><span class="hljs-comment"># Debug info for symbolization.</span><br>CONFIG_DEBUG_INFO=y<br><span class="hljs-comment"># Memory bug detector</span><br>CONFIG_KASAN=y<br>CONFIG_KASAN_INLINE=y<br><span class="hljs-comment"># Required for Debian Stretch</span><br>CONFIG_CONFIGFS_FS=y<br>CONFIG_SECURITYFS=y<br></code></pre></td></tr></table></figure><p>注意删掉相应的注释，例如：# CONFIG_KCOV is not set，否则执行下条命令会有warning，如果不删除在之后进行qemu虚拟化时会出现Failed to start Remount Root and Kernel File Systems的错误。</p><p>再执行如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">make CC=<span class="hljs-string">&quot;/usr/bin/gcc&quot;</span> olddefconfig<br>make CC=<span class="hljs-string">&quot;/usr/bin/gcc&quot;</span> -j8<br></code></pre></td></tr></table></figure><h2 id="制作文件系统"><a href="#制作文件系统" class="headerlink" title="制作文件系统"></a>制作文件系统</h2><p>使用如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://raw.githubusercontent.com/google/syzkaller/master/tools/create-image.sh -O create-image.sh<br>chmod +x create-image.sh<br>./create-image.sh<br></code></pre></td></tr></table></figure><p>最后可以看到stretch.id_rsa、stretch.id_rsa.pub、stretch.img这几个文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">cerises@ubuntu:~/linux/image$ ls<br>chroot  create-image.sh  stretch.id_rsa  stretch.id_rsa.pub  stretch.img<br></code></pre></td></tr></table></figure><h2 id="运行syzkall"><a href="#运行syzkall" class="headerlink" title="运行syzkall"></a>运行syzkall</h2><p>这里需要打开Vmware虚拟机的虚拟化。</p><p>安装qemu。</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">sudo apt-<span class="hljs-built_in">get</span> install qemu-<span class="hljs-keyword">system</span>-x86<br></code></pre></td></tr></table></figure><p>在当前目录创建boot.sh文件，文件内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">qemu-system-x86_64 \<br> -kernel /home/cerises/linux/arch/x86/boot/bzImage \<br> -append &quot;console=ttyS0 root=/dev/sda debug earlyprintk=serial slub_debug=QUZ&quot;\<br> -hda ./stretch.img \<br> -net user,hostfwd=tcp::10021-:22 -net nic   \<br> -enable-kvm \<br> -nographic \<br> -m 2560M \<br> -smp 2 \<br> -pidfile vm.pid \<br><span class="hljs-meta"> 2&gt;</span><span class="bash">&amp;1 | tee vm.log</span><br></code></pre></td></tr></table></figure><p>运行qemu虚拟机有登录提示输入root，无密码登录。</p><p>root@syzkaller:~# </p><p>在Vmware虚拟机使用如下命令，以是否能登录qemu虚拟机判断qemu虚拟机的ssh服务是否成功启动（syzkaller需要使用ssh）。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">ssh -<span class="hljs-selector-tag">i</span> stretch<span class="hljs-selector-class">.id_rsa</span> -<span class="hljs-selector-tag">p</span> <span class="hljs-number">10021</span> -o <span class="hljs-string">&quot;StrictHostKeyChecking no&quot;</span> root@localhost<br></code></pre></td></tr></table></figure><p>结果成功登录</p><p>进入之前下载的syzkaller目录，创建my.cfg配置文件，文件内容如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;target&quot;</span>: <span class="hljs-string">&quot;linux/amd64&quot;</span>,<br>    <span class="hljs-attr">&quot;http&quot;</span>: <span class="hljs-string">&quot;127.0.0.1:56741&quot;</span>,<br>    <span class="hljs-attr">&quot;workdir&quot;</span>: <span class="hljs-string">&quot;/home/cerises/Desktop/syzkaller/workdir&quot;</span>,<br>    <span class="hljs-attr">&quot;kernel_obj&quot;</span>: <span class="hljs-string">&quot;/home/cerises/linux&quot;</span>,<br>    <span class="hljs-attr">&quot;image&quot;</span>: <span class="hljs-string">&quot;/home/cerises/linux/image/stretch.img&quot;</span>,<br>    <span class="hljs-attr">&quot;sshkey&quot;</span>: <span class="hljs-string">&quot;/home/cerises/linux/image/stretch.id_rsa&quot;</span>,<br>    <span class="hljs-attr">&quot;syzkaller&quot;</span>: <span class="hljs-string">&quot;/home/cerises/Desktop/syzkaller&quot;</span>,<br>    <span class="hljs-attr">&quot;procs&quot;</span>: <span class="hljs-number">8</span>,<br>    <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;qemu&quot;</span>,<br>    <span class="hljs-attr">&quot;vm&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;count&quot;</span>: <span class="hljs-number">4</span>,<br>        <span class="hljs-attr">&quot;kernel&quot;</span>: <span class="hljs-string">&quot;/home/cerises/linux/arch/x86/boot/bzImage&quot;</span>,<br>        <span class="hljs-attr">&quot;cpu&quot;</span>: <span class="hljs-number">2</span>,<br>        <span class="hljs-attr">&quot;mem&quot;</span>: <span class="hljs-number">2048</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用./bin/syz-manager -config my.cfg命令运行。注意运行前需要关闭qemu虚拟机</p><p>成功运行！</p><p><img src="2022-02-18_215305.png"></p><h1 id="Syzkaller-crash-DEMO"><a href="#Syzkaller-crash-DEMO" class="headerlink" title="Syzkaller crash DEMO"></a>Syzkaller crash DEMO</h1><p>这部分参考：</p><p><a href="https://github.com/hardenedlinux/Debian-GNU-Linux-Profiles/tree/master/docs/harbian_qa/fuzz_testing">https://github.com/hardenedlinux/Debian-GNU-Linux-Profiles/tree/master/docs/harbian_qa/fuzz_testing</a></p><p>本指南分为三个步骤：</p><ul><li>将导致堆溢出的规则添加到 syzkaller 并重建它</li><li>使用堆溢出代码编译内核</li><li>运行 syzkaller 来寻找 bug</li></ul><h2 id="向-syzkaller-添加测试规则"><a href="#向-syzkaller-添加测试规则" class="headerlink" title="向 syzkaller 添加测试规则"></a>向 syzkaller 添加测试规则</h2><p>该规则写在 $(SYZKALLER_SOURCE)/sys/ 目录下的 *.txt 文件中。它会被 syz-extract 翻译成同一目录下的 *.const 文件。然后我们可以用新规则重建 syzkaller。</p><h3 id="The-grammar-of-txt"><a href="#The-grammar-of-txt" class="headerlink" title="The grammar of *.txt"></a>The grammar of *.txt</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">open</span><span class="hljs-constructor">$proc(<span class="hljs-params">file</span> <span class="hljs-params">ptr</span>[<span class="hljs-params">in</span>, <span class="hljs-params">string</span>[<span class="hljs-string">&quot;/proc/test&quot;</span>]], <span class="hljs-params">flags</span> <span class="hljs-params">flags</span>[<span class="hljs-params">proc_open_flags</span>], <span class="hljs-params">mode</span> <span class="hljs-params">flags</span>[<span class="hljs-params">proc_open_mode</span>])</span> fd<span class="hljs-operator"></span><br><span class="hljs-operator">...</span><br><span class="hljs-operator"></span>proc_open_flags = O_RDONLY, O_WRONLY, O_RDWR, O_APPEND, FASYNC, O_CLOEXEC, O_CREAT, O_DIRECT, O_DIRECTORY, O_EXCL, O_LARGEFILE, O_NOATIME, O_NOCTTY, O_NOFOLLOW, O_NONBLOCK, O_PATH, O_SYNC, O_TRUNC, \__O_TMPFILE<br>proc_open_mode = S_IRUSR, S_IWUSR, S_IXUSR, S_IRGRP, S_IWGRP, S_IXGRP, S_IROTH, S_IWOTH, S_IXOTH<br></code></pre></td></tr></table></figure><p>系统调用的声明由系统调用名、参数和返回值组成，系统调用名的格式如下所示：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">SyscallName$<span class="hljs-keyword">Type</span><br></code></pre></td></tr></table></figure><p>‘’前面的”SyscallName”是系统调用的名称，内核提供的接口，’’后面的”Type”是系统调用的具体类型。在我这里的例子中：</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cos"><span class="hljs-keyword">open</span><span class="hljs-built_in">$proc</span><br></code></pre></td></tr></table></figure><p>表示系统调用“open()”带有一个有限的tpye“proc”，名称由作者确定，限制由后续参数确定，参数格式如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">ArgumentName ArgumentType<span class="hljs-selector-attr">[Limit]</span><br></code></pre></td></tr></table></figure><p>ArgumentName 是 Argument 的名称，ArgumentType 是它的类型。 在我的示例中，有几种类型的参数，如字符串、标志等。“[Limit]”将限制参数的值，如果不具体，syzkaller 将生成一个随机值。</p><figure class="highlight mercury"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mercury"><span class="hljs-keyword">mode</span> flags[proc_open_mode]<br>proc_open_mode <span class="hljs-built_in">=</span> ...<br></code></pre></td></tr></table></figure><p>在我们的示例中，带有 tpye “flags” 的参数 “mode” 将从 “proc_open_mode = ……” 中挑选出一些值。</p><p>声明的最后是返回值。在我的示例中，“fd”是文件描述符。</p><p>系统调用的一些一般声明写在源代码树 $(SYZKALLER_SOURCE)/sys/sys.txt 中。</p><p>在我的示例中，可以通过写入 /proc/test 来触发堆溢出。所以，我们应该将“open”中的“file”参数限制为“/proc/test”，其他人可以引用sys.txt文件。</p><p>案例的规则参考：<a href="https://github.com/hardenedlinux/Debian-GNU-Linux-Profiles/blob/master/docs/harbian_qa/fuzz_testing/proc_operation.txt">https://github.com/hardenedlinux/Debian-GNU-Linux-Profiles/blob/master/docs/harbian_qa/fuzz_testing/proc_operation.txt</a></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">include</span> &lt;linux/fs.h&gt;<br><br><span class="hljs-keyword">open</span><span class="hljs-constructor">$proc(<span class="hljs-params">file</span> <span class="hljs-params">ptr</span>[<span class="hljs-params">in</span>, <span class="hljs-params">string</span>[<span class="hljs-string">&quot;/proc/test&quot;</span>]], <span class="hljs-params">flags</span> <span class="hljs-params">flags</span>[<span class="hljs-params">proc_open_flags</span>], <span class="hljs-params">mode</span> <span class="hljs-params">flags</span>[<span class="hljs-params">proc_open_mode</span>])</span> fd<br>read<span class="hljs-constructor">$proc(<span class="hljs-params">fd</span> <span class="hljs-params">fd</span>, <span class="hljs-params">buf</span> <span class="hljs-params">buffer</span>[<span class="hljs-params">out</span>], <span class="hljs-params">count</span> <span class="hljs-params">len</span>[<span class="hljs-params">buf</span>])</span> len<span class="hljs-literal">[<span class="hljs-identifier">buf</span>]</span><br>write<span class="hljs-constructor">$proc(<span class="hljs-params">fd</span> <span class="hljs-params">fd</span>, <span class="hljs-params">buf</span> <span class="hljs-params">buffer</span>[<span class="hljs-params">in</span>], <span class="hljs-params">count</span> <span class="hljs-params">len</span>[<span class="hljs-params">buf</span>])</span> len<span class="hljs-literal">[<span class="hljs-identifier">buf</span>]</span><br>close<span class="hljs-constructor">$proc(<span class="hljs-params">fd</span> <span class="hljs-params">fd</span>)</span><br><br>proc_open_flags = O_RDONLY, O_WRONLY, O_RDWR, O_APPEND, FASYNC, O_CLOEXEC, O_CREAT, O_DIRECT, O_DIRECTORY, O_EXCL, O_LARGEFILE, O_NOATIME, O_NOCTTY, O_NOFOLLOW, O_NONBLOCK, O_PATH, O_SYNC, O_TRUNC, __O_TMPFILE<br>proc_open_mode = S_IRUSR, S_IWUSR, S_IXUSR, S_IRGRP, S_IWGRP, S_IXGRP, S_IROTH, S_IWOTH, S_IXOTH<br></code></pre></td></tr></table></figure><p>直接在<strong>syzkaller/sys/linux/<strong>下创建</strong>proc_operation.txt</strong>文件</p><h3 id="Rebuild-syzkaller"><a href="#Rebuild-syzkaller" class="headerlink" title="Rebuild syzkaller"></a>Rebuild syzkaller</h3><p>cd 进入源代码树 $(SYZKALLER_SOURCE)，然后运行：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">make clean<br>make bin/syz-extract<br>bin<span class="hljs-regexp">/syz-extract -os linux -arch amd64 -sourcedir /</span>home<span class="hljs-regexp">/cerises/</span>linux proc_operation.txt<br>make all<br></code></pre></td></tr></table></figure><p>“syz-extract”：-arch 是您的测试机器的体系结构，-sourcedir 是内核构建树将被测试的源。</p><p>注意：关于使用您自己的系统调用描述进行重建，您也可以阅读<a href="https://github.com/hardenedlinux/Debian-GNU-Linux-Profiles/blob/master/docs/harbian_qa/fuzz_testing/syz_debug.md#extern-the-syscall">此内容</a>。</p><p>报错：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs elixir">cerises<span class="hljs-variable">@ubuntu</span><span class="hljs-symbol">:~/Desktop/syzkaller</span><span class="hljs-variable">$ </span>bin/syz-extract -os linux -arch amd64 -sourcedir /home/cerises/linux proc_operation.txt<br>generating linux/amd64...<br>sys/linux/<span class="hljs-symbol">proc_operation.txt:</span><span class="hljs-number">4</span><span class="hljs-symbol">:</span><span class="hljs-number">51</span>: len can<span class="hljs-string">&#x27;t be syscall return</span><br><span class="hljs-string">sys/linux/proc_operation.txt:5:51: len can&#x27;</span>t be syscall <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><p>那就删掉len[buf]，之后一切正常。</p><h2 id="将二进制文件复制到测试机"><a href="#将二进制文件复制到测试机" class="headerlink" title="将二进制文件复制到测试机"></a>将二进制文件复制到测试机</h2><p>运行你的虚拟机，然后 cd 进入你的 syzkaller 构建目录，然后运行：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>scp -P <span class="hljs-variable">$(</span>YOUR_PORT) -i ~<span class="hljs-regexp">/.ssh/rsa</span> -r syzkaller/bin root<span class="hljs-variable">@127</span>.0.0.<span class="hljs-number">1</span><span class="hljs-symbol">:</span><span class="hljs-variable">$(</span>YOUR_PATH)<br></code></pre></td></tr></table></figure><ul><li> $(YOUR_PORT) 特定于您的 qemu 标志</li><li>$(YOUR_PATH) 应该添加到 VM 上的环境中。</li></ul><p>本例应该是：</p><p>cd linux/image</p><p>启动qemu</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">scp -P <span class="hljs-number">10021</span> -i .<span class="hljs-regexp">/stretch.id_rsa -r /</span>home<span class="hljs-regexp">/cerises/</span>Desktop<span class="hljs-regexp">/syzkaller/</span>bin root@<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-regexp">/root/</span>bin<br></code></pre></td></tr></table></figure><h2 id="内核模块溢出"><a href="#内核模块溢出" class="headerlink" title="内核模块溢出"></a>内核模块溢出</h2><p>我们将编写一个堆溢出内核模块，该模块在/proc/test下提供了一个proc文件系统接口，/proc/test的文件操作会调用堆溢出函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">a</span> =</span> &#123;<br>                                .open = proc_open,<br>                                .read = proc_read,<br>                                .write = proc_write,<br>&#125;;<br></code></pre></td></tr></table></figure><p>这里只展示了一个函数（带有堆溢出代码）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">ssize_t</span> <span class="hljs-title">proc_write</span> <span class="hljs-params">(struct file *proc_file, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> __user *proc_user, <span class="hljs-keyword">size_t</span> n, <span class="hljs-keyword">loff_t</span> *loff)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> *c = kmalloc(<span class="hljs-number">512</span>, GFP_KERNEL);<br><br>    copy_from_user(c, proc_user, <span class="hljs-number">4096</span>);<br>    printk(DEBUG_FLAG<span class="hljs-string">&quot;:into write!\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>将模块代码放入内核构建树并使用内核构建。</p><p>test.c 参见：<a href="https://github.com/hardenedlinux/Debian-GNU-Linux-Profiles/blob/master/docs/harbian_qa/fuzz_testing/test.c">https://github.com/hardenedlinux/Debian-GNU-Linux-Profiles/blob/master/docs/harbian_qa/fuzz_testing/test.c</a></p><p>Makefile文件</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># at first type on ur terminal that $(uname -r) then u will get the version..</span><br><span class="hljs-comment"># that is using on ur system</span><br> <br>obj-m += test.o<br> <br>KDIR =/usr/src/linux-headers-<span class="hljs-variable">$(<span class="hljs-built_in">shell</span> uname -r)</span><br> <br><span class="hljs-section">all:</span><br>        <span class="hljs-variable">$(MAKE)</span> -C <span class="hljs-variable">$(KDIR)</span> SUBDIRS=<span class="hljs-variable">$(PWD)</span> modules<br> <br><span class="hljs-section">clean:</span><br>        rm -rf *.o *.ko *.mod.* *.symvers *.order<br></code></pre></td></tr></table></figure><p>然后sudo  make</p><p>报错：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">make[2]: *** No rule to make target <span class="hljs-string">&#x27;arch/x86/entry/syscalls/syscall_32.tbl&#x27;</span>, needed by <span class="hljs-string">&#x27;arch/x86/include/generated/uapi/asm/unistd_32.h&#x27;</span>.  Stop.<br>make[1]: *** [arch/x86/Makefile:231: archheaders] Error 2<br>make[1]: Leaving directory <span class="hljs-string">&#x27;/usr/src/linux-headers-5.13.0-30-generic&#x27;</span><br>make: *** [Makefile:9: all] Error 2<br></code></pre></td></tr></table></figure><p>编译内核模块的时候，涉及到一个linux header的问题。（比如说我在5.13.0的系统下编译5.17的驱动）</p><p>解决方案是：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gradle">在<span class="hljs-regexp">/lib/m</span>odules<span class="hljs-regexp">/ 下mkdir一个5.17-rc3/</span><br>然后cd <span class="hljs-number">5.17</span>-rc3/<br>mkdir kernel<br>ln -s <span class="hljs-regexp">/home/</span>cerises<span class="hljs-regexp">/linux ./</span><span class="hljs-keyword">source</span><br>ln -s <span class="hljs-regexp">/home/</span>cerises<span class="hljs-regexp">/linux ./</span>build<br></code></pre></td></tr></table></figure><p>然后make</p><p>Makefile如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stylus">CONFIG_MODULE_SIG=n<br><br><br>obj-m += test<span class="hljs-selector-class">.o</span><br> <br>EXTRA_CFLAGS += -fno-stack-protector -no-pie<br>all:<br>make -C /lib/modules/<span class="hljs-number">5.17</span>-rc3/build M=$(shell pwd) modules<br>clean:<br>rm -f *<span class="hljs-selector-class">.ko</span> *<span class="hljs-selector-class">.o</span> *<span class="hljs-selector-class">.mod</span><span class="hljs-selector-class">.o</span> *<span class="hljs-selector-class">.mod</span><span class="hljs-selector-class">.c</span> *<span class="hljs-selector-class">.symvers</span> *.<span class="hljs-attribute">order</span><br></code></pre></td></tr></table></figure><p>我的系统上$(PWD)会因为找不到当前目录而无法编译，需要换成$(shell  pwd)</p><p>sudo make,又报错</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs bash">/home/cerises/linux/image/<span class="hljs-built_in">test</span>/test.c:45:10: warning: ignoring <span class="hljs-built_in">return</span> value of ‘copy_from_user’ declared with attribute ‘warn_unused_result’ [-Wunused-result]<br>   45 |          copy_from_user(c, proc_user, 4096);<br>      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br>In file included from ./arch/x86/include/asm/preempt.h:7,<br>                 from ./include/linux/preempt.h:78,<br>                 from ./include/linux/spinlock.h:55,<br>                 from ./include/linux/kref.h:16,<br>                 from ./include/linux/mm_types.h:8,<br>                 from ./include/linux/buildid.h:5,<br>                 from ./include/linux/module.h:14,<br>                 from /home/cerises/linux/image/<span class="hljs-built_in">test</span>/test.c:2:<br>In <span class="hljs-keyword">function</span> ‘check_copy_size’,<br>    inlined from ‘copy_from_user’ at ./include/linux/uaccess.h:191:6,<br>    inlined from ‘proc_write’ at /home/cerises/linux/image/<span class="hljs-built_in">test</span>/test.c:45:10:<br>./include/linux/thread_info.h:227:4: error: call to ‘__bad_copy_to’ declared with attribute error: copy destination size is too small<br>  227 |    __bad_copy_to();<br>      |    ^~~~~~~~~~~~~~~<br>make[2]: *** [scripts/Makefile.build:288: /home/cerises/linux/image/<span class="hljs-built_in">test</span>/test.o] Error 1<br>make[1]: *** [Makefile:1831: /home/cerises/linux/image/<span class="hljs-built_in">test</span>] Error 2<br>make[1]: Leaving directory <span class="hljs-string">&#x27;/home/cerises/linux&#x27;</span><br>make: *** [Makefile:8: all] Error 2<br><br></code></pre></td></tr></table></figure><p>解决方法：直接修改/include/linux/thread_info.h的check_copy_size函数，注释掉__bad_copy_to()，改为return true;就可以编译过了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c">check_copy_size(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *addr, <span class="hljs-keyword">size_t</span> bytes, <span class="hljs-keyword">bool</span> is_source)<br>&#123;<br><span class="hljs-keyword">int</span> sz = __builtin_object_size(addr, <span class="hljs-number">0</span>);<br><br><span class="hljs-keyword">if</span> (unlikely(sz &gt;= <span class="hljs-number">0</span> &amp;&amp; sz &lt; bytes)) &#123;<br><span class="hljs-keyword">if</span> (!__builtin_constant_p(bytes))<br>copy_overflow(sz, bytes);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (is_source)<br>__bad_copy_from();<br><span class="hljs-keyword">else</span><br><span class="hljs-comment">//__bad_copy_to();</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (WARN_ON_ONCE(bytes &gt; INT_MAX))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>check_object_size(addr, bytes, is_source);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>目录下生成test.ko，说明编译成功</p><p>接下来就把模块编译进内核</p><p>把test.c cp到/linux/drivers/char/下，然后vim /linux/drivers/char/Kconfig，添加如下：</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vhdl">config TEST_MODULE<br>        tristate <span class="hljs-string">&quot;Heap Overflow Test&quot;</span>       <br>        <span class="hljs-keyword">default</span> y                                           <br>        help<br>          This <span class="hljs-keyword">file</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">to</span> test a <span class="hljs-keyword">buffer</span> overflow.<br></code></pre></td></tr></table></figure><p>/linux/drivers/char/Makefile下添加</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">obj-$(CONFIG_TEST_MODULE) += test.o<br></code></pre></td></tr></table></figure><p>然后make -j8编译。</p><p>启动qemu</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ruby">root<span class="hljs-variable">@syzkaller</span><span class="hljs-symbol">:~</span><span class="hljs-comment"># ls /proc/test</span><br>/<span class="hljs-built_in">proc</span>/test<br></code></pre></td></tr></table></figure><h2 id="修改配置文件并运行-syzkaller"><a href="#修改配置文件并运行-syzkaller" class="headerlink" title="修改配置文件并运行 syzkaller"></a>修改配置文件并运行 syzkaller</h2><p>为了测试文件操作，请在您的配置中启用这些选项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-string">&quot;enable_syscalls&quot;</span>: [<br>                <span class="hljs-string">&quot;open<span class="hljs-variable">$proc</span>&quot;</span>,<br>                <span class="hljs-string">&quot;read<span class="hljs-variable">$proc</span>&quot;</span>,<br>                <span class="hljs-string">&quot;write<span class="hljs-variable">$proc</span>&quot;</span>,<br>                <span class="hljs-string">&quot;close<span class="hljs-variable">$proc</span>&quot;</span><br>],<br></code></pre></td></tr></table></figure><p>修改my.cfg，添加上面的配置</p><p>然后运行 syzkaller：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">bin/syz-manager </span>-<span class="hljs-built_in">config</span> my.cfg -vv <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>跑了段时间</p><p><img src="2022-02-19_210656.png"></p><p><img src="2022-02-19_210806.png"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://github.com/hardenedlinux/Debian-GNU-Linux-Profiles/tree/master/docs/harbian_qa/fuzz_testing">https://github.com/hardenedlinux/Debian-GNU-Linux-Profiles/tree/master/docs/harbian_qa/fuzz_testing</a></p><p><a href="https://bbs.pediy.com/thread-265405.htm">https://bbs.pediy.com/thread-265405.htm</a></p><p><a href="https://www.jianshu.com/p/790b733f80a2">https://www.jianshu.com/p/790b733f80a2</a></p><p><a href="https://www.cnblogs.com/downey-blog/p/10486907.html">https://www.cnblogs.com/downey-blog/p/10486907.html</a></p><p><a href="https://github.com/google/syzkaller/blob/master/docs/linux/setup_ubuntu-host_qemu-vm_x86-64-kernel.md">https://github.com/google/syzkaller/blob/master/docs/linux/setup_ubuntu-host_qemu-vm_x86-64-kernel.md</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux内核调试环境搭建</title>
    <link href="/2021/10/27/Linux%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <url>/2021/10/27/Linux%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="内核源码下载"><a href="#内核源码下载" class="headerlink" title="内核源码下载"></a>内核源码下载</h2><p>内核源码下载渠道：</p><p>（1）git clone 内核，在git checkout某一个分支：git clone <a href="https://github.com/torvalds/linux.git">https://github.com/torvalds/linux.git</a> 适用于git commit补丁前的漏洞调试</p><p>（2）<a href="https://cdn.kernel.org/pub/linux/kernel/v4.x/">https://cdn.kernel.org/pub/linux/kernel/v4.x/</a> 适用于4.x.x版本的内核，下不到更小的发行版</p><p>（3）sudo apt-get source linux-image-$(uname -r) 下载当前内核版本或更小的发行版，缺点：版本不全</p><p>（4）按下面方式获取ubuntu 发行版源码编译，这样小版本的问题也解决了</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">下载linux kernel源码切换分支<br>查看git仓库地址：https:<span class="hljs-regexp">//</span>wiki.ubuntu.com<span class="hljs-regexp">/Kernel/</span>Dev/KernelGitGuide<br>git clone git:<span class="hljs-regexp">//</span>kernel.ubuntu.com<span class="hljs-regexp">/ubuntu/u</span>buntu-xenial.git<br>git tag | grep <span class="hljs-number">4.4</span>.<span class="hljs-number">0</span>-<span class="hljs-number">21</span><br>git checkout Ubuntu-<span class="hljs-number">4.4</span>.<span class="hljs-number">0</span>-<span class="hljs-number">21.37</span><br></code></pre></td></tr></table></figure><p>一般选择方式1，找到漏洞引入的commit，切换过去。或者切到漏洞补丁的commit，然后将补丁手动注释，或者是git checkout patch_commit_id~1，切到补丁的上一个commit</p><p>也可以下载<a href="http://security.ubuntu.com/ubuntu/pool/main/l/linux/">http://security.ubuntu.com/ubuntu/pool/main/l/linux/</a> 中的linux-image-*-*amd64.deb包，解压里面有bzImage，如果能找到对应的vmlinux带符号镜像，那就可以直接调了，不然要想打断点调试，就得编译内核来获取镜像。</p><p>国内clone的很慢，可以用清华的源：<a href="https://mirrors.tuna.tsinghua.edu.cn/help/linux.git/">https://mirrors.tuna.tsinghua.edu.cn/help/linux.git/</a></p><p>克隆主线 linux 代码，使用</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">git clone https:<span class="hljs-regexp">//mi</span>rrors.tuna.tsinghua.edu.cn<span class="hljs-regexp">/git/</span>linux.git<br></code></pre></td></tr></table></figure><h2 id="linux内核编译"><a href="#linux内核编译" class="headerlink" title="linux内核编译"></a>linux内核编译</h2><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-built_in">make</span> mrproper  <span class="hljs-meta">#清理下</span><br><br><br><span class="hljs-built_in">make</span> defconfig<br><span class="hljs-built_in">make</span> menuconfig<br><span class="hljs-built_in">make</span> -j8<br></code></pre></td></tr></table></figure><p>（1）先make defconfig，获取默认的config，这样的config配置少，可以极大提高编译速度，一般几分钟就好了。</p><p>（2）make menuconfig：要进行打断点调试，需要关闭系统的随机化和开启调试信息：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">Processor</span> <span class="hljs-selector-tag">type</span> <span class="hljs-selector-tag">and</span> <span class="hljs-selector-tag">features</span>  <span class="hljs-selector-tag">---</span>&gt; <br>    <span class="hljs-selector-attr">[ ]</span> <span class="hljs-selector-tag">Build</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">relocatable</span> <span class="hljs-selector-tag">kernel</span>                                               <br>        <span class="hljs-selector-attr">[ ]</span>  <span class="hljs-selector-tag">Randomize</span> <span class="hljs-selector-tag">the</span> <span class="hljs-selector-tag">address</span> <span class="hljs-selector-tag">of</span> <span class="hljs-selector-tag">the</span> <span class="hljs-selector-tag">kernel</span> <span class="hljs-selector-tag">image</span> (KASLR) (NEW) <br><br><br><span class="hljs-selector-tag">Kernel</span> <span class="hljs-selector-tag">hacking</span>  <span class="hljs-selector-tag">---</span>&gt;<br>    <span class="hljs-selector-tag">Compile-time</span> <span class="hljs-selector-tag">checks</span> <span class="hljs-selector-tag">and</span> <span class="hljs-selector-tag">compiler</span> <span class="hljs-selector-tag">options</span>  <span class="hljs-selector-tag">---</span>&gt;  <br>        <span class="hljs-selector-attr">[*]</span> <span class="hljs-selector-tag">Compile</span> <span class="hljs-selector-tag">the</span> <span class="hljs-selector-tag">kernel</span> <span class="hljs-selector-tag">with</span> <span class="hljs-selector-tag">debug</span> <span class="hljs-selector-tag">info</span>                                                                  <br>        <span class="hljs-selector-attr">[ ]</span>   <span class="hljs-selector-tag">Reduce</span> <span class="hljs-selector-tag">debugging</span> <span class="hljs-selector-tag">information</span>                                                                      <br>        <span class="hljs-selector-attr">[ ]</span>   <span class="hljs-selector-tag">Produce</span> <span class="hljs-selector-tag">split</span> <span class="hljs-selector-tag">debuginfo</span> <span class="hljs-selector-tag">in</span> <span class="hljs-selector-class">.dwo</span> <span class="hljs-selector-tag">files</span>                                                             <br>        <span class="hljs-selector-attr">[*]</span>   <span class="hljs-selector-tag">Generate</span> <span class="hljs-selector-tag">dwarf4</span> <span class="hljs-selector-tag">debuginfo</span>                                         <br>        <span class="hljs-selector-attr">[*]</span>   <span class="hljs-selector-tag">Provide</span> <span class="hljs-selector-tag">GDB</span> <span class="hljs-selector-tag">scripts</span> <span class="hljs-selector-tag">for</span> <span class="hljs-selector-tag">kernel</span> <span class="hljs-selector-tag">debugging</span>  <br></code></pre></td></tr></table></figure><p>以上配置完成后会在当前目录生成 <code>.config</code> 文件，我们可以使用 <code>grep</code> 进行验证：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># grep CONFIG_DEBUG_INFO .config</span><br>CONFIG_DEBUG_INFO=y<br></code></pre></td></tr></table></figure><p>（3）内核编译</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs awk"> $ nproc       <span class="hljs-comment"># 查看当前的系统核数</span><br> $ make -j <span class="hljs-number">8</span>  <span class="hljs-comment"># 或者采用 make bzImage 进行编译， -j N，表示使用多少核并行编译</span><br> <br> <span class="hljs-comment"># 未压缩的内核文件，这个在 gdb 的时候需要加载，用于读取 symbol 符号信息，由于包含调试信息所以比较大</span><br> $ ls -hl vmlinux <br>-rwxr-xr-x <span class="hljs-number">1</span> root root <span class="hljs-number">449</span>M Feb  <span class="hljs-number">3</span> <span class="hljs-number">14</span>:<span class="hljs-number">46</span> vmlinux<br><br><span class="hljs-comment"># 压缩后的镜像文件 </span><br>$ ls -hl .<span class="hljs-regexp">/arch/</span>x86_64<span class="hljs-regexp">/boot/</span>bzImage<br>lrwxrwxrwx <span class="hljs-number">1</span> root root <span class="hljs-number">22</span> Feb  <span class="hljs-number">3</span> <span class="hljs-number">14</span>:<span class="hljs-number">47</span> .<span class="hljs-regexp">/arch/</span>x86_64<span class="hljs-regexp">/boot/</span>bzImage -&gt; ..<span class="hljs-regexp">/../</span>x86<span class="hljs-regexp">/boot/</span>bzImage<br><br>$ ls -hl .<span class="hljs-regexp">/arch/</span>x86<span class="hljs-regexp">/boot/</span>bzImage<br>-rw-r--r-- <span class="hljs-number">1</span> root root <span class="hljs-number">7.6</span>M Feb  <span class="hljs-number">3</span> <span class="hljs-number">14</span>:<span class="hljs-number">47</span> .<span class="hljs-regexp">/arch/</span>x86<span class="hljs-regexp">/boot/</span>bzImage<br></code></pre></td></tr></table></figure><p>如果要用到userfaultfd、ebpf的系统调用，需要在编译选项中开启：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">General setup  <span class="hljs-comment">---&gt;  </span><br>   [*] <span class="hljs-keyword">Enable</span> bpf() <span class="hljs-keyword">system</span> <span class="hljs-keyword">call</span>                                                <br>   [*] <span class="hljs-keyword">Enable</span> userfaultfd() <span class="hljs-keyword">system</span> <span class="hljs-keyword">call</span>     <br></code></pre></td></tr></table></figure><h2 id="构建initramfs根文件系统"><a href="#构建initramfs根文件系统" class="headerlink" title="构建initramfs根文件系统"></a>构建initramfs根文件系统</h2><h4 id="什么是initramfs-基于ramfs的临时文件系统"><a href="#什么是initramfs-基于ramfs的临时文件系统" class="headerlink" title="什么是initramfs(基于ramfs的临时文件系统)"></a>什么是initramfs(基于ramfs的临时文件系统)</h4><ul><li><p>initramfs 是一种以 cpio 格式压缩后的 rootfs 文件系统，它通常和 Linux 内核文件一起被打包成 boot.img 作为启动镜像</p></li><li><p>BootLoader 加载 boot.img，并启动内核之后，内核接着就对 cpio 格式的 initramfs 进行解压， 并将解压后得到的 rootfs 加载进内存，最后内核会检查 rootfs 中是否存在 init 可执行文件（该 init 文件本质上是一个执行的 shell 脚本），如果存在，就开始执行 init 程序并创建 Linux 系统用 户空间 PID 为 1 的进程，然后将磁盘中存放根目录内容的分区真正地挂载到 / 根目录上，最后通 过 exec chroot . /sbin/init 命令来将 rootfs 中的根目录切换到挂载了实际磁盘分区文件系统中， 并执行 /sbin/init 程序来启动系统中的其他进程和服务。 基于ramfs开发initramfs，取代了initrd。</p></li></ul><h4 id="什么是initrd"><a href="#什么是initrd" class="headerlink" title="什么是initrd"></a>什么是initrd</h4><ul><li><p>initrd代指内核启动过程中的一个阶段，临时挂载文件系统，加载硬盘的基础驱动，进而过渡到最 终的根文件系统 </p></li><li><p>是早期基于ramdisk生成的临时根文件系统的名称 </p></li><li><p>现阶段虽然基于initramfs，但是临时根文件系统也依然存在某些发行版称其为initrd </p></li><li><p>例：CentOS 临时根文件系统命名为 initramfs-<code>uname -r</code>.img Ubuntu 临时根文件系统命名为 initrd-<code>uname -r</code>.img</p></li></ul><h4 id="为什么需要initrd-initramfs"><a href="#为什么需要initrd-initramfs" class="headerlink" title="为什么需要initrd/initramfs"></a>为什么需要initrd/initramfs</h4><ul><li><p>Linux kernel在自身初始化完成之后，需要能够找到并运行第一个用户程序（这个程序通常叫 做“init”程序）。用户程序存在于文件系统之中，因此，内核必须找到并挂载一个文件系统才可以 成功完成系统的引导过程。</p><p>在grub中提供了一个选项“root=”用来指定第一个文件系统，但随着硬件的发展，很多情况下这个 文件系统也许是存放在USB设备，SCSI设备等等多种多样的设备之上，如果需要正确引导，USB或 者SCSI驱动模块首先需要运行起来，可是不巧的是，这些驱动程序也是存放在文件系统里，因此 会形成一个悖论。</p></li><li><p>为解决此问题，Linux kernel提出了一个RAM disk的解决方案，把一些启动所必须的用户程序和驱 动模块放在RAM disk中，这个RAM disk看上去和普通的disk一样，有文件系统，有cache，内核 启动时，首先把RAM disk挂载起来，等到init程序和一些必要模块运行起来之后，再切到真正的文 件系统之中。</p></li><li><p>上面提到的RAM disk的方案实际上就是initrd。 如果仔细考虑一下，initrd虽然解决了问题但并不 完美。 比如，disk有cache机制，对于RAM disk来说，这个cache机制就显得很多余且浪费空间； disk需要文件系统，那文件系统（如ext2等）必须被编译进kernel而不能作为模块来使用。</p></li><li><p>Linux 2.6 kernel提出了一种新的实现机制，即initramfs。顾名思义，initramfs只是一种RAM filesystem而不是disk。initramfs实际是一个cpio归档，启动所需的用户程序和驱动模块被归档成 一个文件。因此，不需要cache，也不需要文件系统。</p></li></ul><h3 id="制作根文件系统：利用busybox生成根文件系统"><a href="#制作根文件系统：利用busybox生成根文件系统" class="headerlink" title="制作根文件系统：利用busybox生成根文件系统"></a>制作根文件系统：利用busybox生成根文件系统</h3><p>（1）下载busybox</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> ~/oslab<br>wget https://busybox.net/downloads/busybox-1.32.1.tar.bz2 <span class="hljs-comment">#下载 备用链接:  https://od.srpr.cc/acgg0/busybox-1.32.1.tar.bz2</span><br>tar -jxvf busybox-1.32.1.tar.bz2 <span class="hljs-comment">#解压</span><br><span class="hljs-built_in">cd</span> ~/oslab/busybox-1.32.1<br></code></pre></td></tr></table></figure><p>（2）编译busybox</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">make menuconfig <span class="hljs-comment">#修改配置如下：</span><br></code></pre></td></tr></table></figure><p>修改配置如下：(空格键勾选)</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">Settings –&gt;<br><span class="hljs-keyword">Build </span>Options<br>[*] <span class="hljs-keyword">Build </span>static <span class="hljs-keyword">binary（no </span><span class="hljs-keyword">share </span>libs）<br></code></pre></td></tr></table></figure><p>编译并安装</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-built_in">make</span> -j $((<span class="hljs-string">`nproc`</span><span class="hljs-number">-1</span>)<br>sudo <span class="hljs-built_in">make</span> install<br></code></pre></td></tr></table></figure><p>（3）准备根文件系统</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> ~/oslab/busybox-1.32.1/_install<br>sudo mkdir dev<br>sudo mknod dev/console c 5 1<br>sudo mknod dev/ram b 1 0<br>sudo touch init<br></code></pre></td></tr></table></figure><p>在init中写入以下内容,你可以使用vim或gedit编辑器写入(<a href="https://www.openvim.com/">vim tutorial</a>)，执行sudo vim init 或 sudo gedit init.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/sh</span><br>echo &quot;INIT SCRIPT&quot;<br>mkdir /proc<br>mkdir /sys<br>mount -t proc none /proc<br>mount -t sysfs none /sys<br>mkdir /tmp<br>mount -t tmpfs none /tmp<br>echo -e &quot;\nThis boot took $(cut -d&#x27; &#x27; -f1 /proc/uptime) seconds\n&quot;<br>exec /bin/sh<br></code></pre></td></tr></table></figure><p>赋予init脚本执行，制作initramfs文件，将x86-busybox下面的内容打包归档成cpio文件，以供 Linux内核做initramfs启动执行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo chmod +x init<br><span class="hljs-built_in">cd</span> ~/oslab/busybox-1.32.1/_install<br>find . -print0 | cpio --null -ov --format=newc | gzip -9 &gt;<br>~/oslab/initramfs-busybox-x64.cpio.gz <span class="hljs-comment"># 注意：该命令一定要在busybox的 _install目录下执行</span><br><span class="hljs-comment"># 注意：每次修改_install,都要重新执行该命令</span><br><span class="hljs-comment">#find . | cpio -o --format=newc &gt; ../rootfs.img</span><br><br></code></pre></td></tr></table></figure><p>（4）运行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> ~/oslab<br><span class="hljs-comment">## qemu 以图形界面，弹出窗口形式运行内核</span><br>qemu-system-x86_64 -s -kernel ~/oslab/linux-4.9.263/arch/x86_64/boot/bzImage<br>-initrd ~/oslab/initramfs-busybox-x64.cpio.gz --append <span class="hljs-string">&quot;nokaslr</span><br><span class="hljs-string">root=/dev/ram init=/init&quot;</span><br><br><span class="hljs-comment">## Ubuntu 20.04/20.10 环境下如果出现问题，可执行以下指令 (部分Ubuntu20.04/20.10系统编译linux后bzImage也在x86_64中, 根据实际情况选择bzImage路径)</span><br>qemu-system-x86_64 -s -kernel ~/oslab/linux-4.9.263/arch/x86/boot/bzImage -<br>initrd ~/oslab/initramfs-busybox-x64.cpio.gz --append <span class="hljs-string">&quot;nokaslr root=/dev/ram</span><br><span class="hljs-string">init=/init&quot;</span><br><br><span class="hljs-comment">## 如不希望qemu以图形界面启动，而希望以无界面形式启动，输出重定向到当前shell，使用以下命令</span><br>qemu-system-x86_64 -s -kernel ~/oslab/linux-4.9.263/arch/x86_64/boot/bzImage<br>-initrd ~/oslab/initramfs-busybox-x64.cpio.gz --append <span class="hljs-string">&quot;nokaslr</span><br><span class="hljs-string">root=/dev/ram init=/init console=ttyS0 &quot;</span> -nographic<br></code></pre></td></tr></table></figure><h3 id="下载文件系统镜像"><a href="#下载文件系统镜像" class="headerlink" title="下载文件系统镜像"></a>下载文件系统镜像</h3><p>（1）如果漏洞不涉及很多模块，较为简单的就是下载一个ctf kernel pwn的镜像文件，对镜像文件rootfs.img 进行解包修改：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">mkdir core<br>mv rootfs<span class="hljs-selector-class">.img</span> ./core/rootfs<span class="hljs-selector-class">.cpio</span><span class="hljs-selector-class">.gz</span> <br>cd core<br>gunzip rootfs<span class="hljs-selector-class">.cpio</span><span class="hljs-selector-class">.gz</span><br>cpio -idmv &lt; rootfs<span class="hljs-selector-class">.cpio</span><br>rm -rf rootfs.cpio<br></code></pre></td></tr></table></figure><p>将漏洞exp放入，再重新打包：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-builtin-name">find</span> . | cpio -o <span class="hljs-attribute">--format</span>=newc &gt; <span class="hljs-built_in">..</span>/rootfs.img<br></code></pre></td></tr></table></figure><p>(2) 涉及较为复杂的模块，如网络，驱动，或者应用层组件，可以获取下面syzkaller的镜像：</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">sudo</span> <span class="hljs-string">apt-get</span> <span class="hljs-string">install</span> <span class="hljs-string">debootstrap</span><br><span class="hljs-string">wget</span> <span class="hljs-string">https</span>://<span class="hljs-string">raw</span>.<span class="hljs-string">githubusercontent</span>.<span class="hljs-string">com</span>/<span class="hljs-string">google</span>/<span class="hljs-string">syzkaller</span>/<span class="hljs-string">master</span>/<span class="hljs-string">tools</span>/<span class="hljs-built_in">create-image.sh</span> -<span class="hljs-string">O</span> <span class="hljs-built_in">create-image.sh</span><br><span class="hljs-string">chmod</span> +<span class="hljs-string">x</span> <span class="hljs-built_in">create-image.sh</span><br>./<span class="hljs-built_in">create-image.sh</span><br></code></pre></td></tr></table></figure><p>上述步骤操作完，已经可以使用scp命令将exp放入镜像中。但也可以自己配置网络上网，下载Exp到系统中：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">将<span class="hljs-regexp">/etc/</span>network/interfaces中设置成dhcp,将eth0 改成ip addr 显示的网卡:<br>auto eth0<br>iface eth0 inet dhcp<br>重启网络服务:<span class="hljs-regexp">/etc/i</span>nit.d/networking restart<br></code></pre></td></tr></table></figure><p>此时qemu可以访问外网，host还不能和qemu通信，所以配置下guest与 host 通信。</p><h4 id="配置-guest与-host-通信"><a href="#配置-guest与-host-通信" class="headerlink" title="配置 guest与 host 通信"></a>配置 guest与 host 通信</h4><p>使用tap方式上网：</p><p>a、host主机上的配置：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">sudo apt-get <span class="hljs-keyword">install </span>uml-utilities<br>sudo apt-get <span class="hljs-keyword">install </span><span class="hljs-keyword">bridge-utils</span><br><span class="hljs-keyword"></span><br>sudo ifconfig ens33 down              <br>sudo <span class="hljs-keyword">brctl </span><span class="hljs-keyword">addbr </span><span class="hljs-keyword">br0 </span>                     <br>sudo <span class="hljs-keyword">brctl </span><span class="hljs-keyword">addif </span><span class="hljs-keyword">br0 </span>ens33            <br>sudo <span class="hljs-keyword">brctl </span>stp <span class="hljs-keyword">br0 </span>off                 <br>sudo <span class="hljs-keyword">brctl </span>setfd <span class="hljs-keyword">br0 </span><span class="hljs-number">1</span>                 <br>sudo <span class="hljs-keyword">brctl </span>sethello <span class="hljs-keyword">br0 </span><span class="hljs-number">1</span>              <br>sudo ifconfig <span class="hljs-keyword">br0 </span><span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span> promisc up      <br>sudo ifconfig ens33 <span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span> promisc up      <br>sudo dhclient <span class="hljs-keyword">br0</span><br><span class="hljs-keyword"></span>sudo <span class="hljs-keyword">brctl </span><span class="hljs-keyword">show </span><span class="hljs-keyword">br0</span><br><span class="hljs-keyword"></span>sudo <span class="hljs-keyword">brctl </span><span class="hljs-keyword">showstp </span><span class="hljs-keyword">br0</span><br><span class="hljs-keyword"></span><br>sudo ip tuntap <span class="hljs-keyword">add </span>mode tap user $(whoami)<br>sudo tunctl -t tap0 -u root    <br>sudo <span class="hljs-keyword">brctl </span><span class="hljs-keyword">addif </span><span class="hljs-keyword">br0 </span>tap0<br>sudo ifconfig tap0 <span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span><br>sudo <span class="hljs-keyword">brctl </span><span class="hljs-keyword">showstp </span><span class="hljs-keyword">br0</span><br><span class="hljs-keyword"></span><br>删除tap0<br>sudo tunctl -d tap0<br></code></pre></td></tr></table></figure><p>b、qemu虚拟机上的配置：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs awk">设置ssh登陆：<br>sudo vim <span class="hljs-regexp">/etc/</span>pam.d/sshd<br>注释下面两处，运行root和普通用户ssh登陆：<br><br><span class="hljs-comment"># Disallow non-root logins when /etc/nologin exists.</span><br><span class="hljs-comment">#account    required     pam_nologin.so</span><br><br><br><span class="hljs-comment"># Uncomment and edit /etc/security/access.conf if you need to set complex</span><br><span class="hljs-comment"># access limits that are hard to express in sshd_config.</span><br><span class="hljs-comment"># account  required     pam_access.so</span><br><br>sudo <span class="hljs-regexp">/etc/i</span>nit.d/ssh start  <span class="hljs-comment">#启动ssh</span><br></code></pre></td></tr></table></figure><h2 id="启动qemu进行漏洞调试"><a href="#启动qemu进行漏洞调试" class="headerlink" title="启动qemu进行漏洞调试"></a>启动qemu进行漏洞调试</h2><p>qemu 启动脚本：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs livescript">sudo qemu-system-x86_64 <span class="hljs-string">\</span><br>    -m <span class="hljs-number">2</span>G <span class="hljs-string">\</span><br>    -smp <span class="hljs-number">2</span> <span class="hljs-string">\</span><br>    -kernel ./bzImage <span class="hljs-string">\</span><br>    -append <span class="hljs-string">&quot;console=ttyS0 root=/dev/sda earlyprintk=serial&quot;</span><span class="hljs-string">\</span><br>    -drive file=./stretch.img,format=raw <span class="hljs-string">\</span><br>    -net nic <span class="hljs-string">\</span><br>    -net tap,ifname=tap0,script=<span class="hljs-literal">no</span>,downscript=<span class="hljs-literal">no</span> <span class="hljs-string">\</span><br>    -enable-kvm <span class="hljs-string">\</span><br>    -nographic <span class="hljs-string">\</span><br>    -pidfile vm.pid <span class="hljs-string">\</span><br>    <span class="hljs-number">2</span>&gt;&amp;<span class="hljs-number">1</span> | tee vm.log<br></code></pre></td></tr></table></figure><p>参数解释：</p><p>“smp”指定了处理器的个数；</p><p>“m”指定了内存的大小；</p><p>“kernel”指定编译生成的内核镜像的存放位置；</p><p>“append”是内核启动的附加参数；</p><p>“drive”指定之前制作生成的根文件系统的镜像位置；</p><p>-nographic：通常，QEMU使用SDL显示VGA输出，使用这个选项，使qemu成为简单的命令行应用程序；</p><p><code>-S</code>参数可以让QEMU启动后CPU先Pause住不运行；</p><p> <code>-s</code>参数是<code>-gdb tcp::1234</code>的简写，意思是让QEMU侧的gdb server侦听在1234端口等待调试．</p><p>由于设置为tap方式，host和qemu在同一个网段里，同时其他host虚拟机也可以进行ssh连接qemu</p><p>默认登陆的是root用户，添加sudo 用户：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">adduser pwn</span><br><span class="hljs-attribute">usermod -aG sudo pwn</span><br></code></pre></td></tr></table></figure><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># 选项说明</span><br><span class="hljs-meta"># -m 指定内存数量</span><br><span class="hljs-meta"># -kernel 指定 bzImage 的镜像路径</span><br><span class="hljs-meta"># -s 等价于 -gdb tcp::1234 表示监听 1234 端口，用于 gdb 连接</span><br><span class="hljs-meta"># -S 表示加载后立即暂停，等待调试指令。不设置这个选项内核会直接执行</span><br><span class="hljs-meta"># -nographic 以及后续的指令用于将输出重新向到当前的终端中，这样就能方便的用滚屏查看内核的输出日志了。</span><br></code></pre></td></tr></table></figure><h2 id="GDB-调试"><a href="#GDB-调试" class="headerlink" title="GDB 调试"></a>GDB 调试</h2><p>在使用 <code>qemu-system-x86_64</code> 命令启动内核以后，进入到我们从编译机器上拷贝过来的 Linux 内核源代码目录中，在另外一个终端我们来启动 gdb 命令：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cmake">[linux-<span class="hljs-number">4.19</span>.<span class="hljs-number">172</span>]$ gdb <br>(gdb) <span class="hljs-keyword">file</span> vmlinux           <span class="hljs-comment"># vmlinux 位于目录 linux-4.19.172 中</span><br>(gdb) <span class="hljs-keyword">target</span> remote :<span class="hljs-number">1234</span><br>(gdb) <span class="hljs-keyword">break</span> start_kernel     <span class="hljs-comment"># 有些文档建议使用 hb 硬件断点，我在本地测试使用 break 也是 ok 的</span><br>(gdb) c    <span class="hljs-comment"># 启动调试，则内核会停止在 start_kernel 函数处</span><br></code></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://de4dcr0w.github.io/%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AALinux%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83.html">https://de4dcr0w.github.io/%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AALinux%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83.html</a></p><p><a href="https://blog.csdn.net/scarecrow_byr/article/details/17741133">https://blog.csdn.net/scarecrow_byr/article/details/17741133</a></p><p><a href="https://github.com/google/syzkaller/blob/master/docs/linux/setup_ubuntu-host_qemu-vm_x86-64-kernel.md">https://github.com/google/syzkaller/blob/master/docs/linux/setup_ubuntu-host_qemu-vm_x86-64-kernel.md</a></p><p><a href="https://www.ebpf.top/post/qemu_gdb_busybox_debug_kernel/">https://www.ebpf.top/post/qemu_gdb_busybox_debug_kernel/</a></p><p><a href="https://imkira.com/QEMU-GDB-Linux-Kernel/">https://imkira.com/QEMU-GDB-Linux-Kernel/</a></p><p><a href="http://staff.ustc.edu.cn/~ykli/os2021/lab/lab1.pdf">http://staff.ustc.edu.cn/~ykli/os2021/lab/lab1.pdf</a></p>]]></content>
    
    
    <categories>
      
      <category>LinuxKernel</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LinuxKernel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo guide</title>
    <link href="/2021/10/24/hexo_guide/"/>
    <url>/2021/10/24/hexo_guide/</url>
    
    <content type="html"><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://hexo.io/zh-cn/docs/github-pages">将 Hexo 部署到 GitHub Pages</a></p><p><a href="https://hexo.io/zh-cn/docs/">https://hexo.io/zh-cn/docs/</a></p><p><a href="https://fuhailin.github.io/Hexo-images/">https://fuhailin.github.io/Hexo-images/</a></p><h2 id="分类和标签"><a href="#分类和标签" class="headerlink" title="分类和标签"></a>分类和标签</h2><p> Front-matter 中设置</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs subunit">categories:<br>- Diary<br><span class="hljs-keyword">tags:</span><br>- PS3<br>- Games<br></code></pre></td></tr></table></figure><h2 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h2><h3 id="绝对路径本地引用"><a href="#绝对路径本地引用" class="headerlink" title="绝对路径本地引用"></a>绝对路径本地引用</h3><p>当Hexo项目中只用到少量图片时，可以将图片统一放在source/images文件夹中，通过markdown语法访问它们。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">![](<span class="hljs-regexp">/images/im</span>age.jpg)<br></code></pre></td></tr></table></figure><p>图片既可以在首页内容中访问到，也可以在文章正文中访问到。</p><h3 id="相对路径本地引用"><a href="#相对路径本地引用" class="headerlink" title="相对路径本地引用"></a>相对路径本地引用</h3><p>图片除了可以放在统一的images文件夹中，还可以放在文章自己的目录中。文章的目录可以通过站点配置文件_config.yml来生成。<br><code>post_asset_folder: true</code><br>将_config.yml文件中的配置项post_asset_folder设为true后，执行命令$ hexo new post_name，在source/_posts中会生成文章post_name.md和同名文件夹post_name。将图片资源放在post_name中，文章就可以使用相对路径引用图片资源了。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs less">!<span class="hljs-selector-attr">[]</span>(image.jpg)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
